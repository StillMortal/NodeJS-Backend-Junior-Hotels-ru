#include <iostream>
#include <iomanip>
#include <string>
#include <vector>
#include <unordered_map>

using namespace std;

//ЗАДАНИЯ НА СООБРАЗИТЕЛЬНОСТЬ

//1 задание
//        Есть 90 человек. Каждый из этих 90 человек относится к одной из двух категорий. Одни на все вопросы говорят правду, другие — всегда врут. У каждого ровно 1 любимое блюдо из списка (макароны/пельмени/вареники). Каждому задают три вопроса:
//Ваше любимое блюдо — макароны?
//Ваше любимое блюдо — пельмени?
//Ваше любимое блюдо — вареники?
//Результаты получились такие:
//на первый вопрос утвердительно ответило 45 человек,
//на второй — 35,
//на третий — 30.
//Сколько человек всегда говорят правду?

// Ответ: 70, так как они всегда говорят правду, следовательно, каждый из них даст ответ "Да" лишь на один из трёх вопросов,
// оставшиеся 20 человек дадут ответа "Да" на два из трёх вопросов (на нелюбимые блюда).



//2 задание
//        Есть числа от трех до одиннадцати. Есть квадрат — 3 на 3 клетки:
//а б в
//        г д е
//ё ж з
//(Буквы ничего не значат, кроме того, что числа не повторяются)
//Можно ли расставить числа в клетки квадрата таким образом, что перемножения чисел в строках дает тот же результат, что и произведение чисел в столбцах с теми же номерами?
//Если можно — расставьте, если нельзя — объясните почему.

// Ответ: можно, например, применяя основную теорему арифметики. Ниже расстановка:
// 11 10 4
//  5  7 6
//  8  3 9



//3 задание
//        Ученые разработали новый материал неизвестной прочности. Они знают, что материал разбивается при падении с высоты от 1 метра до 5 000 метров. Но не знают, с какой именно высоты. Чтобы определить прочность, ученые поднимают предмет на некоторую высоту и сбрасывают его оттуда. Их задача — определить, начиная с какой именно высоты предмет начнет разбиваться.
//Специальная платформа, с помощью которой они осуществляют эксперимент, скидывает предмет только с дискретных высот (1, 2, 3 ... 4999, 5000 метров — платформа не может скинуть предмет, например, с 2,5 метров. Точности в 1 метр ученым вполне достаточно). При падении с высоты "n" метров предмет уничтожается. Если же его сбрасывали с высоты ниже "n", то его можно использовать в повторных экспериментах.
//Нужно АБСОЛЮТНО ТОЧНО найти ту высоту, начиная с которой предметы разрушаются. Сделать это нужно за МИНИМАЛЬНО возможное число экспериментов. У ученых при этом всего 2 предмета, но они абсолютно одинаковые. Каким образом этого можно достигнуть? Сколько экспериментов при этом максимально потребуется?

// Ответ: эта задача аналогична задаче "Загадка про яйцо Фаберже" вот тут https://www.youtube.com/watch?v=nykLcW97ZBg
// Ответ: 100



//4 задание
//В университетскую столовую пришли трое студентов купить пирожки.
// Один хочет купить треть всех имеющихся в столовой пирожков и еще 2 пирожка.
// Другой хочет купить четверть от всех имеющихся пирожков и ещё 3 пирожка.
// А третий хочет купить пятую часть всех пирожков и ещё 8 пирожков.
// Если все трое купят столько пирожков, сколько планируют,
// то в столовой как раз закончатся все пирожки.
// Сколько пирожков есть в столовой?

// Решение: 1/3 * x + 2 + 1/4 * x + 3 + 1/5 * x + 8 = 47/60 * x + 13, где x - общее количество пирожков,
// следовательно, x = 60. Проверим, 60 - 1/3 * 60 + 2 + 1/4 * 60 + 3 + 1/5 * 60 + 8 = 0
// Ответ: 60.



//Задача 1
//Написать метод/функцию, который/которая на вход принимает массив городов. В качестве результата возвращает строку, где города разделены запятыми, а в конце стоит точка.
//Пример:
//«Москва, Санкт-Петербург, Воронеж.»

// потратил 7 минут, учитывая время проверки.
// Ответ в виде функции vector_to_string
string vector_to_string(vector<string> &v) {
    string output;
    for (string s: v) {
        output += s + ',';
    }
    output.back() = '.';

    return output;
}



//Задача 2
//Написать метод/функцию, который/которая на вход принимает число (float), а на выходе получает число, округленное до пятерок.
//Пример:
//27 => 25, 27.8 => 30, 41.7 => 40.

// потратил 10 минут, учитывая время проверки.
// Ответ в виде функции round_to_multiple_of_five
int round_to_multiple_of_five(float f) {
    int integer_part = (int) f;
    float remainder = integer_part % 5 + f - integer_part;

    int add = remainder >= 2.5 ? 5 : 0;

    return integer_part - integer_part % 5 + add;
}



//Задача 3
//Написать метод/функцию, который/которая на вход принимает число (int),
//а на выходе выдает слово “компьютер” в падеже, соответствующем указанному количеству.
//Например, «25 компьютеров», «41 компьютер», «1048 компьютеров».

// потратил 10 минут, учитывая время проверки, но я уже решал подобную задачу здесь https://stepik.org/lesson/5047/step/6?thread=solutions&unit=1086.
// Ответ в виде функции computers
string computers(int num) {
    int d = num % 10;
    int h = num % 100;
    string s;
    if (d == 1 and h != 11) {
        s = "";
    }
    else if (1 < d and d < 5 and not (11 < h and h < 15)) {
        s = "а";
    }
    else {
        s = "ов";
    }

    return to_string(num) + " компьютер" + s;
}


//Задача 4
//Написать метод/функцию, который/которая на вход принимает целое число, а на выходе возвращает то,
// является ли число простым (не имеет делителей кроме 1 и самого себя).

// потратил 7 минут, учитывая время проверки
// Ответ в виде функции is_prime
bool is_prime(int num) {
    int divisor = 2;
    while (divisor * divisor <= num) {
        if (num % divisor == 0) {
            return false;
        }
        divisor += 1;
    }

    return num != 1;
}



//Задача 5
//Написать метод, который определяет, какие элементы присутствуют в двух экземплярах в каждом из массивов (= в двух и более, причем в каждом).
// На вход подаются два массива. На выходе массив с необходимыми совпадениями.
//Пример:
//[7, 17, 1, 9, 1, 17, 56, 56, 23], [56, 17, 17, 1, 23, 34, 23, 1, 8, 1]
//На выходе [1, 17]


// потратил 20 минут, учитывая время проверки
// Ответ в виде функции common_elements_of_two_arrays
vector<int> common_elements_of_two_arrays(vector<int> &v1, vector<int> &v2) {
    unordered_map<int, int> m1;
    unordered_map<int, int> m2;

    for (int i = 0; i < min(v1.size(), v2.size()); ++i) {
        ++m1[v1[i]];
        ++m2[v2[i]];
    }

    if (v1.size() < v2.size()) {
        for (size_t i = v1.size(); i < v2.size(); ++i) {
            ++m2[v2[i]];
        }
    }
    else {
        for (size_t i = v2.size(); i < v1.size(); ++i) {
            ++m1[v1[i]];
        }
    }

    vector<int> common_elements;
    for (auto pair: m1) {
        if (pair.second > 1 and m2[pair.first] > 1) {
            common_elements.push_back(pair.first);
        }
    }

    return common_elements;
}



//Задача 6
//Написать метод, который в консоль выводит таблицу умножения.
// На вход метод получает число, до которого выводит таблицу умножения.
// В консоли должна появиться таблица. Например, если на вход пришло число 5, то получим:
//
//Важно:
//●	В последней строке между числами ровно по одному пробелу должно выводиться.
//●	В каждом столбце числа должны быть выровнены по правому краю.

// потратил 15 минут, учитывая время проверки
// Ответ в виде функции multiplication_table
void multiplication_table(int num) {
    cout << setw(to_string(num).size()) << "";
    for (int val = 1; val <= num; ++val) {
        cout << setw(to_string(val * num).size() + 1) << val;
    }
    cout << '\n';

    for (int row = 1; row <= num; ++row) {
        cout << setw(to_string(num).size()) << row;
        for (int column = 1; column <= num; ++column) {
            cout << setw(to_string(column * num).size() + 1) << row * column;
        }
        cout << '\n';
    }
}


int main() {
    vector<string> v = {"Москва", "Санкт-Петербург", "Воронеж"};
    cout << vector_to_string(v) << "\n\n";

    cout << round_to_multiple_of_five(27) << '\n';
    cout << round_to_multiple_of_five(27.8) << "\n\n";

    cout << computers(25) << '\n';
    cout << computers(41) << '\n';
    cout << computers(1048) << "\n\n";

    cout << is_prime(25) << '\n';
    cout << is_prime(4) << '\n';
    cout << is_prime(3) << '\n';
    cout << is_prime(2) << '\n';
    cout << is_prime(1) << "\n\n";

    vector<int> v1 = {7, 17, 1, 9, 1, 17, 56, 56, 23};
    vector<int> v2 = {56, 17, 17, 1, 23, 34, 23, 1, 8, 1};
    for (int vi: common_elements_of_two_arrays(v1, v2)) {
        cout << vi << ' ';
    }
    cout << "\n\n";

    multiplication_table(10);

    return 0;
}
